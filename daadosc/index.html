<!DOCTYPE html>
<html>
	
	<head>
		<title>DAAD OSC</title>
		<meta charset="utf8">
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
        <style>
            * {
                margin: 0;
                padding: 0;
                border: 0;
                font-size: inherit;
                font-weight: inherit;
                font-family: inherit;
                font: inherit;
                text-align: inherit;
                text-transform: inherit;
                vertical-align: inherit;
                list-style-type: none;
                outline: none;
                text-decoration: none;
                border-collapse: collapse;
                border: none;
                border-color: transparent;
                color: inherit;
                line-height: inherit;
                transition: all 0s linear; 
                background-repeat: no-repeat;
                position: relative;
            }
            body {
                overflow: hidden;
            }
        </style>
    </head>
    <body>



        <script>
            var music = new Audio();
            music.crossOrigin = "anonymous";
            music.preload = 'auto';
            music.volume = 0.8;
            music.muted = false;
            music.src = "Ben-Klock-Fadi-Mohem-Prefix-Klockworks.mp3";
            //music.src = "sin.mp3"
            var musicLoaded = false;
            var audioCtx = null;
            var audioSrc = null;
            var analyser = null;
            var frequencyData = [ 128, 128 ];
            oscCanvas = document.createElement( 'canvas' );
            oscCanvas.height = 0;
            oscCanvas.width = 0;
            oscCanvas.setAttribute( 'id', 'spectro' );
            
            document.body.appendChild(oscCanvas);

            var canvasCtx = oscCanvas.getContext( "2d" );
 
            function resizeCanvas() {
                oscCanvas.width = window.innerWidth;
                oscCanvas.height = window.innerHeight;
            }
            resizeCanvas();
            window.addEventListener( 'resize', resizeCanvas );
            oscCanvas.addEventListener('click', () => {
                if ( music.paused ) {
                    if ( ( window.AudioContext || window.webkitAudioContext ) && music.src.length ) {

                        if ( !audioCtx ) audioCtx = new ( window.AudioContext || window.webkitAudioContext )();
                        if ( !audioSrc ) audioSrc = audioCtx.createMediaElementSource( music );
                        analyser = audioCtx.createAnalyser();
                        analyser.fftSize = 32;
                        analyser.smoothingTimeConstant = 0.8;
                        frequencyData = new Uint8Array( analyser.frequencyBinCount );
                        audioSrc.connect( analyser );
                        audioSrc.connect( audioCtx.destination );

                        music.play();
                    }
                } else {
                    music.pause();
                }
            });
            var corners = {
                right: 0.7,
                bottom: 1
            }

            function renderMeter() {
                requestAnimationFrame( renderMeter );
                canvasCtx.clearRect(0, 0, oscCanvas.width, oscCanvas.height);
                canvasCtx.fillStyle = "rgba( 255, 0, 0, 0.5 )"; 
                canvasCtx.beginPath();
                canvasCtx.moveTo( oscCanvas.width * corners.right, oscCanvas.height * corners.bottom );
                
                if ( analyser && !music.paused ) analyser.getByteFrequencyData( frequencyData );
                //if ( analyser && !music.paused ) analyser. getByteTimeDomainData( frequencyData );
                
                for ( let i = 1; i < frequencyData.length; i++ ) {
                    const x = Math.abs( ( oscCanvas.width * corners.right ) - ( i * ( oscCanvas.width / frequencyData.length ) ) )
                    const y = Math.abs( ( oscCanvas.height * corners.bottom ) - ( i * ( oscCanvas.height / frequencyData.length ) ) );
                    const divider = ( i < frequencyData.length / 2 ) ? ( frequencyData.length / 2 ) / i : ( frequencyData.length / 2 ) / ( frequencyData.length - i )
                    canvasCtx.lineTo( x, y + ( ( frequencyData[ i ] - 128 ) / divider ) );
                }

                canvasCtx.lineTo( oscCanvas.width * Math.abs( corners.right - 1 ), oscCanvas.height * Math.abs( corners.bottom - 1 ) );
                canvasCtx.lineTo( oscCanvas.width * corners.right, oscCanvas.height * Math.abs( corners.bottom - 1 ) );
                canvasCtx.lineTo( oscCanvas.width * corners.right, oscCanvas.height * corners.bottom );
                canvasCtx.fill();
            }
            const centerX = oscCanvas.width / 2;
            const centerY = oscCanvas.height / 2;
            const radius = 50;
            const rotationAngle = 45; // in degrees

            // Convert the rotation angle to radians
            const angleInRadians = (rotationAngle * Math.PI) / 180;

            function renderMeter2() {
                requestAnimationFrame( renderMeter2 );
                canvasCtx.save();
                canvasCtx.translate( centerX, centerY );
                canvasCtx.rotate(angleInRadians);
                canvasCtx.fillStyle = 'red';
                canvasCtx.beginPath();

                canvasCtx.arc(0, 0, radius, 0, Math.PI); // Draws a half-circle from 0 to Ï€ radians

                //canvasCtx.lineTo(-radius, 0); // Line from the end of the arc back to the start
                if ( analyser && !music.paused ) analyser.getByteFrequencyData( frequencyData );
                //if ( analyser && !music.paused ) analyser. getByteTimeDomainData( frequencyData );
                
                for ( let i = 1; i < frequencyData.length; i++ ) {
                    const unit = radius / ( ( frequencyData.length / 2 ) );
                    const x = radius - i * unit;
                    console.log( x );
                    const divider = ( i < frequencyData.length / 2 ) ? ( frequencyData.length / 2 ) / i : ( frequencyData.length / 2 ) / ( frequencyData.length - i )
                    canvasCtx.lineTo( x, 0 + ( ( frequencyData[ i ] - 128 ) / divider ) );
                }
                // Close the path and fill the shape
                canvasCtx.closePath();
                canvasCtx.fill();

                // Restore the canvas to its original state
                canvasCtx.restore();
            }




            requestAnimationFrame( renderMeter2 );

        </script>
    </body>
</html>